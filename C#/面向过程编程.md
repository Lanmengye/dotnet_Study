## <a name="catalog">目录</a>
- [变量与常量](#title1)
- [数据类型与类型转换](#title2)
- [运算符](#title3)
- [流程控制](#title4)
- [数组](#title5)
- [函数](#title6)
- [异常处理](#title7)


## <a name="title1">[变量与常量](#catalog)</a>     
**变量**是经过计算机赋值在内存中其值可以改变的量。变量是一个存储位置的符号名称，程序以后可以对这个存储位置进行赋值和修改操作。

**变量命名规范：**     
- 必须以字母或下划线开头。
- 只能由字母、数字、下划线组成，不能包含空格、标点符号、运算符及其他符号。
- 不能使用关键字。     

**变量的声明**：
		1. 指定变量要包含的数据的类型  
		2. 为它分配标识符（变量名）    

**变量的使用**		    
变量都要先声明再**赋值**，然后才能使用（在类中直接声明的变量叫做类的成员变量，类的成员变量声明以后可以不赋初值，因为会有默认值。在方法中声明的变量叫做局部变量，局部变量使用之前必须声明并赋值）。    

**变量的类型**大致分为3种：     
	1. 实例变量    
  不带任何关键字声明的变量称为实例变量。实例变量在其所在的方法调用结束后，其数据将会被清除掉，所占的内存空间也会被释放。  
	2. 静态变量   
  使用“static”关键字修饰的变量称为静态变量，静态变量在函数调用结束后仍保留变量值，直到程序结束前一直存在。另外，静态变量不能再类的方法中定义。  
	3. 局部变量
  局部变量是指在一个独立的代码块中声明的变量，它只在这个代码块中有效，一旦离开这个范围，将不再存在。

**常量**在程序运行期间，其值是不能改变的。       
**常量的声明**要使用关键字```const```并指定其数据类型、常量名及初始值。
     

## <a name="title2">[数据类型与类型转换](#catalog)</a>
### 数据类型
一个变量声明所指定的数据的类型称为**数据类型**。数据类型，或者简称为类型，是具有相似特征和行为的个体的分类。
- 基本类型
	1. 整型   
  C#支持8种整型：sbyte、byte、short、ushort、int、uint、long、ulong   
	2. 浮点型  
  C#支持3种浮点型：float、double、decimal(用于金融计算的十进制浮点类型)  
	3. 布尔型  
  布尔型的取值为true或false
	4. 字符型  
  C#的字符型可以保存单个字符的值，在C#中，char类型的值需要放在单引号中。
- 复杂类型  
	1. 字符串型   
C#中的字符串类型可以包含多个字符组成的字符串，字符串类型的值需要放在双引号中。   
	2. 枚举   
枚举类型是一种特殊的值类型，是一组已命名的数值常量，常用于声明一组命名的常数。枚举的类型必须是8个整型类型之一。枚举用关键字```enum```来声明定义。格式如下：   
```enum``` 枚举名[: 数据类型]
{ 成员1 [=整型常数1], 成员2 [=整型常数2], 成员3 [=整型常数3],…, 成员n [=整型常数n]}
没有指定特定的枚举类型，一般会默认枚举元素的基础类型为int。默认状态下，将0赋值给枚举对象的第一个元素，然后对每个后续的枚举元素按1递增。但是，也可以在初始化阶段给元素直接赋值。
	3. 结构体
结构类型是一种值类型，用关键字```struct```来声明，它是一种堆栈分配的复杂数据类型，它不支持继承。结构主要用于创建小型的对象，并可以节省内存。结构可以包含构造函数、常量、字段、方法、属性、索引器、运算符、事件和嵌套类型等。 
  
与类型有关的两个额外的关键字时```null```和```void```。```null```值表明变量不引用任何有效的对象。```void```表示没有类型，或者没有任何值。
可空类型：一般不能将```null```赋给值类型，为了声明可以存储```null```的变量，要使用可空修饰符？

### 值类型与引用类型
在C#中，根据数据类型的不同，变量存储在两个不同的位置。第一个位置是程序的堆栈，每个程序都有自己的堆栈，其他程序是不能直接访问的。在程序的方法被调用时，所有的本地变量都放入程序的堆栈，调用完毕后，变量出栈并检索。第二个位置是托管内存中的堆，在程序运行的过程中，CLR定期检查并清理堆栈中不能访问的变量，释放该变量占用的内存。存储在第一个位置的数据类型是值类型，存储在第二个位置的数据类型是引用类型。   
所有类型都可以划分为值类型和引用类型两类。它们的区别在于复制方式：值类型的数据总是进行值复制，而引用类型的数据总是进行引用复制。  
当值类型的变量被赋值时，在堆栈中创建的是两个相同的数据副本，其中一个变量值的改变不会引起另一个变量的改变。当引用类型的变量被赋值时，在内存堆中创建的是对同一个位置的两个引用。 
 
### 类型转换
只有具有相同数据类型的对象才能够互相操作，为了进行不同数据类型的运算（如整型和浮点型的运算等），需要把数据从一种类型转换为另一种类型，即进行类型转换。C#有两种转换方式。
- 隐式转换：无需指明转换，编译器自动将操作数转换为相同的类型。     
当两个不同数据类型的操作数进行运算时，编译器会试图对其进行自动类型转换，使两者变为同一类型。不同的数据类型具有不同的赋值空间，如果试图将一个需要较大赋值空间的数据类型转换为赋值空间较小的数据，就会出现错误。
- 显示转换    
在C#中，为了避免隐式转换可能带来的错误，需要使用强制转换来执行显示转换，强制类型转换的形式为：(类型说明符)(待转换的数据)，其作用是把待转换的数据的类型强制转换成类型说明符所表示的数据类型。每个数值数据类型都包含一个```Parse()```方法，它允许将字符串转换成对应的数值类型，另外，C#允许使用```System.Convert```类提供的类型转换方法来转换数据类型。   
    
## <a name="title3">[运算符](#catalog)</a>
运算符又称操作符，是指对一系列成为操作数的值或变执行数学或逻辑运算/操作来生成新值（成为结果）。通常将操作符划分为3个大类：一元操作符、二元操作符和三元操作符，它们对应的操作数分别是1个，2个和3个。结合性决定相似操作符的执行顺序，优先级决定不相似操作符的执行顺序。
1. 算术运算符     
算术运算符是用来处理四则运算的符号，如（+、-、*、/、%、++、--）
2. 字符串运算符    
字符串运算符只有一个，就是“+”。除了作为算术运算符外，它还可以将字符串连接起来，变成合并的新字符串。
3. 赋值运算符    
赋值运算符是把其右边表达式的值赋给左边的变量或常量。
4. 逻辑运算符      
逻辑运算符通常用来测试真假值，如（==、!=、&&、||、!）
5. 位运算符       
位运算符用于做一些快速的数学运算，如（&、|、^（异或）、<<、>>、~（非））
6. 其他运算符     
```new```：创建一个类的实例  
```typeof```：获取数据类型  
```.```：获取对象的方法或属性  
```?:```：问号表达式  

## <a name="title4">[流程控制](#catalog)</a>
- 条件语句
	- ```if```语句
    1. 单分支结构
		```C#
		if(布尔（逻辑/条件）表达式)
		{	
			代码块	
		}
		```
	2. 双分支语句
		```C#
		if(布尔（条件/逻辑表达式）)
		{	
			代码块1		
		}
		else
		{	
			代码块2	
		}
		```
	3. 多分支语句
		```C#
		if(布尔（条件/逻辑表达式）)
		{
			代码块1		
		}		
		else if(布尔（条件/逻辑表达式）)
		{	
			代码块2		
		}
		else
		{	
			代码块3	
		}
		```
 
	- ```switch```语句   
	```switch```语句具有以下几个组成部分：
		1. 初始的```switch```语句。这条语句在圆括号中包括要测试的值。
		2. 大括号括住了```switch```语句的内容，与函数或if语句相似。
		3. 一条或多条```case```语句，其中每条语句都指定了一个值，以此比较在```switch```语句中指定的值。如果值匹配，就会执行```case```语句后面的语句。否则，就会尝试下一个```case```。
		4. ```break```语句用于结束每一个```case```。这将跳到```switch```的末尾。如果没有包括```break```，可能会执行多个```case```中的语句，而不管它们是否匹配。
		5. 可以选择包括```default```情况，其中接着一条或多条语句，如果其他```case```都不匹配，则将执行这些语句。

		```C#
		switch(expression)	
		{
			case constant :
				statements
			default :
				statements
		}
		```
	- 问号表达式    
   语法格式：```variable=(condition)?(value if true):(value if false);```
   如果条件为真，将会使用问号（?）后面的值；如果条件为假，则会使用冒号（：）后面的值。
	- 空接合操作符  
   语法格式：```expression1??expression2```  
   如果expression1不为```null```，就返回expression1的值，不对另一个表达式求值，如果expression1求值为```null```，就返回expression2的值。

- 循环语句
	- ```for```语句    
   for循环有3个参数，它们之间用分号隔开。
		1. 第一个参数指定一个变量，并赋予它一个初始值。这称为初始表达式（initial expression），因为它建立了循环的初始状态。
		2. 第二个参数是一个条件，要使循环持续运行，它就必须保持为真。这称为循环的条件（condition）。
		3. 第三个参数是一条随同循环的每次迭代而执行的语句。这称为递增表达式（increment expression），因为它通常用于递增计数器。递增表达式是在每次循环迭代的末尾执行的。
   在指定了三个参数之后，使用左大括号（{）指示代码块的开始，并在代码块的末尾使用右大括号（}）。在循环的每次迭代中，都将执行大括号之间的所有语句。
	- ```foreach```语句            
   凡是具有```GetEnumerator()```这个方法的类型都能使用```foreach```来遍历。其实通过```foreach```遍历数据，实际上是调用了一个“枚举器”来遍历数据，和```foreach```一点关系都没有，```foreach```只是一个语法上的简化而已。希望一个类被“枚举”、“遍历”，就要实现类，该类是一个“枚举器”。 
         - type为代表collection中每一项的variable声明数据类型。可将类型设为```var```，编译器将根据集合类型推断数据项的类型。
          - variable是只读变量，foreach循环自动将collection中的下一项赋给它。variable的作用域限于循环主体。
          - collection表示多个数据项的表达式，如数组。
          - statement是每次循环都要执行的循环主体。
	```C#
	foreach(type variable in collection)
		statement
	```
	 
	- ```while```语句  
   ```while```语句在圆括号中包括条件，其后接着大括号内的语句块。当条件成立时执行代码块。
	- ```do……while```语句  
  ```do```后接着大括号的代码块，之后接```while```条件，它与```while```的区别是：```do……while```环的条件是在循环的末尾（而不是开头）测试的。```do…while```语句无论条件是否成立，代码块至少都会执行一次。
	- ```break```语句退出循环  
   当程序遇到```break```语句时，它将会跳过循环的其余部分，并继续执行脚本中的循环末尾的右大括号后面的第一条语句。
	- ```continue```语句继续执行    
   ```continue```语句会跳过循环中的其余部分，但是与```break```语句不同的是，它会继续执行循环的下一次迭代。
	- ```return```语句控制循环    
   ```return```语句主要用于结束函数的执行，并可以将需要的参量返回。可以用于包括循环语句在内的函数中的任何地方。
	- ```while```和```for```循环适用场景    
如果希望条件为```true```就一直执行某个操作，应该使用```while```结构，```for```主要用于重复次数已知的循环，比如从0~n的计数。```do/while```类似于```while```循环，区别在于它至少会循环一次。

- C#预处理指令
控制流语句中的条件表达式在运行时求值。相反，C#预处理器在编译时调用。预处理指令告诉C#编译器要编译哪些代码，并指出如何处理代码中的特定错误和警告。C#预处理指令还可以告诉C#编辑器有关代码组织的信息。
	- 排除和包含代码：控制何时以及如何包含代码
		```C#
		#if LINUX
		...
		#elif WINDOWS
		...
		#endif 
		```
	- 定义预处理符号  
可采用两种方式定义预处理符号：使用```#define```指令；编译时使用define选项  
要取消符号定义，可以采取和使用```#define```相同的方式来使用```#undef```指令	

	- 生成错误和警告：插入```#error```和```#warning```指令可以分别生成错误和警告消息
	- 关闭警告消息：使用```#pragma```指令可以用来关闭或还原警告
	- nowarn:<warn list>选项：将其作为编译器选项使用，影响整个编译过程，获得与```#pragma```相同的结果
	- 指定行号：利用```#line```指令可以改变C#编译器在报告错误或警告时显示的行号。在```#line```指令后添加default，会反转之前的所有```#line```的效果，并指示编译器报告真实的行号，而不是之前使用```#line```指定的行号。
	- 可视编辑器提示
C#允许使用```#region```指令声明代码区域。```#region```和```#endregion```必须成对使用，两个指令都可以选择在指令后面跟随一个描述性的字符串。除此之外还可以将一个区域嵌套到另一个区域中。

## <a name="title5">[数组](#catalog)</a>
利用数组声明，可以在单个变量中存储同一种类型的多个数据项，而且可以利用索引来单独访问这些数据项，索引从0开始。

- 数组的声明  
在C#中，使用方括号声明数组变量。首先要指定数组元素的类型，后跟一对方括号，再输入变量名。如```string[] languages```，方括号中指定了数组的维数。使用更多的逗号，可以定义更多的维，数组总维数等于逗号数加1。

- 数组的实例化和赋值
声明数组之后，可以立即为其填充数据。方法是在一对大括号中使用以逗号分隔的数据项列表，该方法只有在同一语句中声明并赋值。  
```C# 
string[] languages = { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp" };
```
如果在声明后赋值，则需要使用```new```关键字。自C#3.0起，不必在```new```后面指定数组的数据类型，只要编译器能根据初始化列表中的数据类型推断出数组元素的类型。但是，方括号仍然不可缺少。
```C#
string[] languages;
languages=new string[] { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp" };
languages = new [] { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp"};
```
C#支持使用将```new```关键字作为声明语句的一部分，只要将```new```关键字作为数组赋值的一部分，就可以同时在方括号内指定数组的大小。在初始化语句中指定的数组的大小必须和大括号中包含的元素数量相匹配。分配数组但不指定初始值仍然会初始化每个元素，“运行时”将每个元素初始化为它们的默认值。
```C#
string[] languages = new string[] { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp" };
string[] languages = new string[8] { "C#", "COBOL", "Java", "C++", "Visual Basic", "Pascal", "Fortran", "Lisp" };
string[] languages = new string[8];
```
- 多维数组与交错数组
多维数组的每个元素的大小必须一致。交错数组不需要具有一致的大小，但交错数组要求为内部的每个数组都创建数组实例，要使用```new```实例化交错数组的内部元素。
```C#
int[,] cells = { { 1, 0, 2 }, { 1, 2, 0 }, { 1, 2, 1 } };
int[][] cells = { new int[] { 1, 0, 2, 0 }, new int[] { 1, 0, 2 }, new int[] { 1, 0 }, new int[] { 1 } };
```

- 数组的使用
可以使用方括号表示法，也就是所谓的数组访问符，来访问数组中一个特定的数据项。数组的长度是固定的，不能随便更改，除非重新创建数组。除此之外，越过数组的边界（或长度）会造成“运行时”报错。  
数组常用的静态方法：```Sort()```，```Reverse()```和```Clear()```  
常用的实例方法：```GetLength()```和```Clone()```  
字符串可以当做字符数组来访问其中的每一个字符，字符串的```ToCharArray()```方法，将整个字符串作为字符数组访问。

## <a name="title6">[函数/方法](#catalog)</a>
- 概念  
函数（方法）组合一系列语句以执行特定操作或计算特定结果。它能够为构成程序的语句提供更好的结构和组织。  方法总是和类型——通常是类——关联。类型将相关的方法分为一组。  
方法通过实参接收数据，实参由方法的参数或形参定义。参数是调用者用于向被调用的方法传递数据的变量。方法通过返回值将数据返回给调用者。方法调用由方法名称和实参列表构成。完全限定的方法名称包括命名空间、类型名称和方法名称；每部分以句点符号分隔。

	- 命名空间  
命名空间是一种分类机制，用于组合功能相关的所有类型。调用方法并非一定要提供命名空间。假如，假定要调用的方法与发出调用的方法在同一个命名空间中，就没有必要指定命名空间。也可以利用```using```指令避免每次调用方法都指定命名空间限定符。
	- 类型名称  
调用静态方法时，如果目标方法跟调用者不在同一个类型中，就需要使用类型名称限定符，如果要调用的方法在当前类型中，C#就允许在调用该方法时省略名称。类型本质上是对方法及相关数据进行组合的一种方式。
	- 作用域  
一个编程元素的“作用域”是指可以通过它的非限定名称引用到它的区域。
	- 方法名称  
每个方法调用都包含一个方法名称。
	- 形参和实参  
方法可接收任意数量的形参，每个形参都具有特定的数据类型。调用者为形参提供的值称为实参，每个实参都要和一个形参对应。
	- 方法返回值
利用返回值，可以将调用方法所产生的结果返回给调用者。并不是每个方法都有返回值，```void```返回类型的方法没有返回值。

- 方法的声明  
	- 形式参数声明  
在方法声明的圆括号内可以添加形式参数列表，列表的每个参数都包含参数类型和参数名，每个参数以逗号分隔。
	- 方法返回类型声明  
在方法名之前需添加一个方法返回类型，如果方法没有返回值，则返回类型为```void```

```C#    
		static 返回类型 函数名称 (形参列表)   
		{
			// 函数体...
		}
```

- ```using```指令
完全限定的命名空间名称可能很长，很笨拙。可将一个或多个命名空间的所有类型“导入”文件，这样在使用它们时就不需要进行完全限定。在C#中，程序员通过使用```using```指令来实现。```using```指令不会导入任何嵌套命名空间中的类型。  
可以利用```using```指令为命名空间或类型取一个别名。别名是在```using```指令起作用的范围内使用的替代名称。别名最常见的两个涌入是消除两个同名类型的歧义和缩写长名称。如：```using Timer=System.Timers.Timer;```

- ```Main()```的返回值和参数
“运行时”通过一个```string```数组参数将命名行参数传给```Main()```，如果需要从非```Main()```的方法中访问哪些参数，可用```System.Environment.GetCommandLineArgs()```方法返回由命令行参数构成的数组。    ```Main()```方法还会返回一个```int```，返回值对于```Main()```声明来说是可选的。但如果有返回值，程序就可以将状态码返回给调用者。根据约定，非零的返回值代表错误。

- 方法的参数
	- 值参数  
参数默认是传值的，换言之，参数表达式的值会复制到目标参数中。  
如果以传值方式传递一个引用类型的变量，引用（地址）本身会从调用者复制给方法参数。其结果就是，虽然目标方法更改不了调用者变量的值，即更改不了引用（地址）本身，但可以更改引用所指向的数据。另一方面，对于值类型的参数，参数获得的是值的副本，所以在被调用的方法中更改参数不会影响调用者的原始变量。
	- 引用参数(```ref```)  
如果被调用的方法将参数指定为```ref```，那么调用者在调用这个方法的时候，提供的实参应该是附加了```ref```前缀的变量（而不是值），用作```ref```参数的变量必须在传给被调用的方法之前赋值，因为赋值被调用的方法可能从这个变量中读取值。这样调用者就显式地指定了目标方法可以对它接收的任何```ref```参数进行重新赋值。事实上，```ref```参数只是传递的变量的别名。
	- 输出参数(```out```)  
如果方法要获取一个变量引用，并且指向变量中写入而不从中读取，这时更安全的做法是以引用的方式传入一个未初始化的局部变量，为此，代码中需要用```out```修饰参数类型。  
```out```参数在功能上和```ref```参数完全一致，唯一的区别是，C#语言对于别名变量的读写有不同的规定。如果参数被标记为```out```，编译器会核实在方法所有正常返回的代码路径中，是否都对该参数进行了赋值，如果没有赋值，编译器会报错，指出代码没有对其进行初始化。  
如果一个方法要返回多个值，可以将方法拆分成多个方法，每个方法返回一个值，也可以使用```out```或```ref```参数，还可以使用元组(```Tuple```)类型来表示多个值。
	- 参数数组  
C#提供了关键字```params```，允许在调用方法时提供数量可变的参数，而不是方法事先固定好参数数量。  
参数数组要注意以下几点：
	  - 参数数组不一定是方法的唯一参数，但必须是方法声明后的最后一个参数。由于只有最后一个参数才可能是参数数组，所以方法最多只能有一个参数数组。
	  - 调用者可以指定和参数数组对应的零个实参，这会造成传递的参数数组包含零个数据项。
	  - 参数数组是类型安全的——实参的类型必须兼容与参数数组中元素的类型。
	  - 调用者可以显式地使用数组，而不是以逗号分隔的参数列表。
	  - 假如目标方法的实现要求一个最起码的参数数量，请在方法中显示指定必须提供的参数。

	- 可选参数  
从C#4.0开始，语言的设计者增添了对可选参数的支持。声明方法时将常量值赋给参数，以后调用方法时就不必每个参数都指定。可选参数一定放在所有必须的参数（无默认值的参数）后面且默认值必须是常量或者说是必须是能在编译时确定的值。
	- 命名参数  
利用命名参数，调用者可显示地为一个参数赋值，而不是像以前那样只能依据参数顺序来决定那个值赋给哪个参数。利用命名参数是以牺牲方法接口的灵活性为代价的，过去，参数名可以自由更改，不会造成调用代码无法编译的情况，但是在添加了命名参数后，参数名就成为方法接口的一部分。更改名后才能会导致使用命名参数的代码无法编译。

- 递归  
“递归地调用方法”或者“用递归实现方法”意味着方法调用它本身。

- 方法重载  
一个类中的所有方法都必须有唯一签名，C#根据方法名、参数数据类型或者参数数量的不同来定义唯一性。假如两个方法只是返回数据类型不同，那么就会造成一个编译错误。假如一个类包含两个或者多个同名的方法，就会发生方法重载。对于重载的方法，参数的数量和/或数据类型肯定是不同的。  
方法重载是一种操作性多态。如果由于数据的变化造成同一个逻辑操作具有许多（“多”）形式（“态”），就会发生“多态”。  实现重载方法时常采用的一种模式是：开发者只需在一个方法中实现核心逻辑，其他所有重载版本都调用那个方法。

## <a name="title7">[异常处理](#catalog)</a>   
程序引发异常会在终止执行当前分支，跳到调用栈中用于处理异常的第一个代码块，如果程序未提供异常处理，程序会向用户报告发生了未处理的异常。为了解决这个问题，有必要提供一个机制对错误进行恰当的处理，例如像用户报告一条更有意义的错误消息。这个过程称为**捕捉异常**。  
首先要用```try```块将可能引发异常的代码，```try```块之后必须紧跟着一个或多个```catch```块(或/和一个```finally```块)。```catch```块可选择指定异常的数据类型。只要数据类型与异常类型匹配，对应的```catch```块就会执行。但是，假如一直找不到合适的```catch```块，引发的异常就会变成一个未处理的异常，就好像没有进行异常处理一样。处理异常的顺序非常重要。```catch```块必须按照从最具体到最不具体排序。```System.Exception```数据类型是最不具体的，所以它应该最后出现。无论控制是正常地离开```try```块还是由于```try```块中的代码引发异常而离开的，只要控制离开```try```块，```finally```块就会执行。```finally```块的作用是提供一个最终位置，在其中放入无论是否发生异常都要执行的代码。```finally```块最适合用来执行资源清理。  
C#允许开发人员从代码中引发异常，如果引发一个异常，会使执行从异常的引发点跳转到与引发异常类型兼容的第一个```catch```。为了引发异常，需要有```exception```的实例，使用关键字```new```，后跟异常的数据类型，从而创建了这样的实例。大多数异常类型都允许在引发该类型的异常时传递消息，以便在发生异常时获取消息。有时```catch```块能捕捉到异常，但不能正确或完整地处理它。在这种情况下，可以让这个```catch```块重新引发异常，具体的办法是使用一个单独的```throw```语句，不要在它后面指定任何异常。